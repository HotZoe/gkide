/// @file nvim/version.c
///
/// Nvim was forked from Vim 7.4.160.
/// Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred).

#include <inttypes.h>
#include <assert.h>
#include <limits.h>

#include "nvim/api/private/helpers.h"
#include "nvim/vim.h"
#include "nvim/ascii.h"
#include "nvim/iconv.h"
#include "nvim/version.h"
#include "nvim/charset.h"
#include "nvim/macros.h"
#include "nvim/memline.h"
#include "nvim/memory.h"
#include "nvim/message.h"
#include "nvim/screen.h"
#include "nvim/strings.h"

// version and source info generated by the build system
#include "generated/config/miscinfo.h"
#include "generated/config/envdefs.h"
#include "generated/config/versiondef.h"

// ":version", "$ nvim --version"
#define NVIM_VERSION_LONG  "nvim v" NVIM_VERSION_BASIC

char *nvim_gkide_version =
    "NVIM v" NVIM_VERSION_BASIC " (GKIDE v" GKIDE_VERSION_BASIC ")";
static uchar_kt *compiled_sys =
    (uchar_kt *)BUILD_ON_HOST "(" BUILD_OS_NAME " " BUILD_OS_VERSION ")";
static uchar_kt *compiled_usr =
    (uchar_kt *)BUILD_BY_USER;

#ifdef INCLUDE_GENERATED_DECLARATIONS
    #include "version.c.generated.h"
#endif

static char *features[] =
{
#ifdef HAVE_ACL
    "+acl",
#else
    "-acl",
#endif

#if (defined(HAVE_HDR_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)
    #ifdef DYNAMIC_ICONV
    "+iconv/dyn",
    #else
    "+iconv",
    #endif
#else
    "-iconv",
#endif

#ifdef FOUND_WORKING_JEMALLOC
    "+jemalloc",
#else
    "-jemalloc",
#endif

#ifdef NVIM_FEAT_TUI
    "+tui",
#else
    "-tui",
#endif

    NULL
};

/// nvim patch number list
static const int included_patches[] =
{
    0,
};

/// Place to put a short description when adding a feature with a patch.
/// Keep it short, e.g.,: "relative numbers", "persistent undo".
/// Also add a comment marker to separate the lines. See the official Vim
/// patches for the diff format: It must use a context of one line only.
/// Create it by hand or use "diff -C2" and edit the patch.
static char *(extra_patches[]) =
{
    // Add your patch description below this line
    NULL
};

/// Compares a version string to the current GKIDE version.
///
/// @param version Version string like "1.3.42"
///
/// @return true if GKIDE is at or above the version.
bool has_gkide_version(const char *const version_str)
FUNC_ATTR_PURE
FUNC_ATTR_WARN_UNUSED_RESULT
FUNC_ATTR_NONNULL_ALL
{
    const char *p = version_str;
    int gkide_major = 0;
    int gkide_minor = 0;
    int gkide_patch = 0;

    if(!ascii_isdigit(*p))
    {
        return false;
    }

    gkide_major = atoi(p);
    p = strchr(p, '.'); // Find the next dot.

    if(p)
    {
        p++; // Advance past the dot.

        if(!ascii_isdigit(*p))
        {
            return false;
        }

        gkide_minor = atoi(p);
        p = strchr(p, '.');

        if(p)
        {
            p++;

            if(!ascii_isdigit(*p))
            {
                return false;
            }

            gkide_patch = atoi(p);
        }
    }

    return (gkide_major < GKIDE_VERSION_MAJOR
            || (gkide_major == GKIDE_VERSION_MAJOR
                && (gkide_minor < GKIDE_VERSION_MINOR
                    || (gkide_minor == GKIDE_VERSION_MINOR
                        && gkide_patch <= GKIDE_VERSION_PATCH))));
}

/// Compares a version string to the current Nvim version.
///
/// @param version Version string like "1.3.42"
///
/// @return true if Nvim is at or above the version.
bool has_nvim_version(const char *const version_str)
FUNC_ATTR_PURE
FUNC_ATTR_WARN_UNUSED_RESULT
FUNC_ATTR_NONNULL_ALL
{
    const char *p = version_str;
    int nvim_major = 0;
    int nvim_minor = 0;
    int nvim_patch = 0;

    if(!ascii_isdigit(*p))
    {
        return false;
    }

    nvim_major = atoi(p);
    p = strchr(p, '.'); // Find the next dot.

    if(p)
    {
        p++; // Advance past the dot.

        if(!ascii_isdigit(*p))
        {
            return false;
        }

        nvim_minor = atoi(p);
        p = strchr(p, '.');

        if(p)
        {
            p++;

            if(!ascii_isdigit(*p))
            {
                return false;
            }

            nvim_patch = atoi(p);
        }
    }

    return (nvim_major < NVIM_VERSION_MAJOR
            || (nvim_major == NVIM_VERSION_MAJOR
                && (nvim_minor < NVIM_VERSION_MINOR
                    || (nvim_minor == NVIM_VERSION_MINOR
                        && nvim_patch <= NVIM_VERSION_PATCH))));
}

/// Checks whether a Vim patch has been included.
///
/// @param n Patch number.
///
/// @return true if patch `n` has been included.
bool has_nvim_patch(int n)
{
    for(int i = 0; included_patches[i] != 0; i++)
    {
        if(included_patches[i] == n)
        {
            return true;
        }
    }

    return false;
}

/// generated nvim version dictionary info for remote API object
Dictionary gen_version_dict(void)
{
    Dictionary d = ARRAY_DICT_INIT;

    PUT(d, "major", INTEGER_OBJ(NVIM_VERSION_MAJOR));
    PUT(d, "minor", INTEGER_OBJ(NVIM_VERSION_MINOR));
    PUT(d, "patch", INTEGER_OBJ(NVIM_VERSION_PATCH));
    PUT(d, "api_level", INTEGER_OBJ(NVIM_API_VERSION));
    PUT(d, "api_compatible", INTEGER_OBJ(NVIM_API_COMPATIBLE));
    PUT(d, "api_prerelease", BOOLEAN_OBJ(NVIM_API_PRERELEASE));

    return d;
}

void ex_version(exargs_st *eap)
{
    // Ignore a ":version 9.99" command.
    if(*eap->arg == NUL)
    {
        msg_putchar('\n');
        list_version();
    }
}

/// List all features aligned in columns, dictionary style.
static void list_features(void)
{
    int nfeat = 0;
    int width = 0;

    // Find the length of the longest feature
    // name, use that + 1 as the column width
    int i;

    for(i = 0; features[i] != NULL; ++i)
    {
        int l = (int)STRLEN(features[i]);

        if(l > width)
        {
            width = l;
        }

        nfeat++;
    }

    width += 1;

    if(Columns < width)
    {
        // Not enough screen columns - show one per line
        for(i = 0; features[i] != NULL; ++i)
        {
            version_msg(features[i]);

            if(msg_col > 0)
            {
                msg_putchar('\n');
            }
        }

        return;
    }

    // The rightmost column doesn't need a separator.
    // Sacrifice it to fit in one more column if possible.
    int ncol = (int)(Columns + 1) / width;
    int nrow = nfeat / ncol + (nfeat % ncol ? 1 : 0);

    // i counts columns then rows. idx counts rows then columns.
    for(i = 0; !got_int && i < nrow * ncol; ++i)
    {
        int idx = (i / ncol) + (i % ncol) * nrow;

        if(idx < nfeat)
        {
            int last_col = (i + 1) % ncol == 0;
            msg_puts(features[idx]);

            if(last_col)
            {
                if(msg_col > 0)
                {
                    msg_putchar('\n');
                }
            }
            else
            {
                while(msg_col % width)
                {
                    int old_msg_col = msg_col;
                    msg_putchar(' ');

                    if(old_msg_col == msg_col)
                    {
                        break; // XXX: Avoid infinite loop.
                    }
                }
            }
        }
        else
        {
            if(msg_col > 0)
            {
                msg_putchar('\n');
            }
        }
    }
}

void list_version(void)
{
    MSG_PUTS("\n    Version: " NVIM_VERSION_LONG "@" RELEASE_PACKAGE_NAME);
    MSG_PUTS("\n Build date: " BUILD_TIMESTAMP);
    MSG_PUTS("\n Build type: " NVIM_BUILD_TYPE);
    MSG_PUTS("\nModified at: " GIT_COMMIT_DATE " " GIT_COMMIT_TIME " " GIT_COMMIT_ZONE);
    MSG_PUTS("\nCompiled by: ");
    MSG_PUTS(compiled_usr);
    MSG_PUTS("@");
    MSG_PUTS(compiled_sys);

    // When adding features here, don't forget to update the list of internal
    // variables in 'eval.c'. Print the list of extra patch descriptions if
    // there is at least one.
    if(extra_patches[0] != NULL)
    {
        MSG_PUTS("\n\nExtra patches:\n");
        char *s = "";

        for(int i = 0; extra_patches[i] != NULL; ++i)
        {
            MSG_PUTS(s);
            s = ", ";
            MSG_PUTS(extra_patches[i]);
        }
    }

    version_msg("\n\nOptional features included (+) or excluded (-):\n");
    list_features();

    size_t len;
    char msg_buf[MAXPATHL] = { 0 };

    // gkide system home
    snprintf(msg_buf, MAXPATHL, "\n    $%s: ", ENV_GKIDE_SYS_HOME);
    len = strlen(msg_buf);
    if(gkide_sys_home != NULL)
    {
        snprintf(msg_buf + len, MAXPATHL, "%s", gkide_sys_home);
    }
    version_msg(msg_buf);

    // gkide user home
    snprintf(msg_buf, MAXPATHL, "\n    $%s: ", ENV_GKIDE_USR_HOME);
    len = strlen(msg_buf);
    if(gkide_usr_home != NULL)
    {
        snprintf(msg_buf + len, MAXPATHL, "%s", gkide_usr_home);
    }
    version_msg(msg_buf);

    // directories layout
    version_msg("\n     Default Layout: bin, etc, plg, doc, mis\n");
    version_msg("\n      System config: $" ENV_GKIDE_SYS_CONFIG
                " ,then $GKIDE_SYS_HOME/etc/config.nvl");
    version_msg("\n        User config: $" ENV_GKIDE_USR_CONFIG
                " ,then $GKIDE_USR_HOME/etc/config.nvl");
}

/// Output a string for the version message. If it's going to wrap,
/// output a newline, unless the message is too long to fit on the
/// screen anyway.
///
/// @param s
static void version_msg(char *s)
{
    int len = (int)STRLEN(s);

    if(!got_int
       && (len < (int)Columns)
       && (msg_col + len >= (int)Columns)
       && (*s != '\n'))
    {
        msg_putchar('\n');
    }

    if(!got_int)
    {
        MSG_PUTS(s);
    }
}


/// Show the intro message when not editing a file.
void maybe_intro_message(void)
{
    if(bufempty()
       && (curbuf->b_fname == NULL)
       && (firstwin->w_next == NULL)
       && (vim_strchr(p_shm, SHM_INTRO) == NULL))
    {
        intro_message(FALSE);
    }
}

/// Give an introductory message about Vim.
/// Only used when starting Vim on an empty file, without a file name.
/// Or with the ":intro" command (for Sven :-).
///
/// @param colon TRUE for ":intro"
void intro_message(int colon)
{
    static char *(lines[]) = {
        N_("NVIM v" NVIM_VERSION_BASIC),
        "",
        N_("by Charlie WONG et al."),
        N_("nvim is open source and freely distributable"),
        N_("https://github.com/gkide/gkide"),
        "",
        N_("type :help nvim<Enter>       if you are new  "),
        N_("type :CheckHealth<Enter>     to optimize nvim"),
        N_("type :q<Enter>               to exit         "),
        N_("type :help<Enter>            for help        "),
        "",
        N_("Help poor children in Uganda!"),
        N_("type :help iccf<Enter>       for information "),
    };

    // blanklines = screen height - # message lines
    size_t lines_size = ARRAY_SIZE(lines);
    assert(lines_size <= LONG_MAX);
    long blanklines = Rows - ((long)lines_size - 1l);

    // Don't overwrite a statusline. Depends on 'cmdheight'.
    if(p_ls > 1)
    {
        blanklines -= Rows - topframe->fr_height;
    }

    if(blanklines < 0)
    {
        blanklines = 0;
    }

    // start displaying the message lines after half of the blank lines
    long row_num = blanklines / 2;

    // Show the empty message, 4/8
    // Show the uganda message, 2/8
    // Show the sponsor message, 1/8
    // Show the register message, 1/8
    int magic = (int)time(NULL);

    if(((row_num >= 2) && (Columns >= 50)) || colon)
    {
        char *p = NULL;

        for(int i=0, replace=0; i < (int)lines_size; ++i, replace=0)
        {
            p = lines[i];

            // check the last two lines of messages
            if((i+1)==(int)lines_size || (i+2)==(int)lines_size)
            {
                if((magic & 1) == 0)
                {
                    p = ""; // show nothing, 4/8
                }
                else
                {
                    if(strstr(p, "children") != NULL)
                    {
                        replace = 1;
                    }

                    if(!replace && strstr(p, "iccf") != NULL)
                    {
                        replace = 2;
                    }

                    if((magic & 2) == 0)
                    {
                        if((magic & 4) == 0)
                        {
                            // show sponsor message, 1/8
                            if(replace==1)
                            {
                                p = N_("Become a registered Vim user!");
                            }
                            else if(replace==2)
                            {
                                p = N_("type :help register<Enter>   for information ");
                            }
                        }
                        else
                        {
                            // show register message, 1/8
                            if(replace==1)
                            {
                                p = N_("Sponsor Vim development!");
                            }
                            else if(replace==2)
                            {
                                p = N_("type :help sponsor<Enter>    for information ");
                            }
                        }
                    }
                    else
                    {
                        // show uganda message, 2/8
                    }
                }
            }

            if(*p != NUL)
            {
                do_intro_line(row_num, (uchar_kt *)p, 0);
            }

            row_num++;
        }
    }

    for(int i=0; i < blanklines/2; ++i)
    {
        do_intro_line(row_num, (uchar_kt *)"", 0);
        row_num++;
    }

    // Make the wait-return message appear just below the text.
    if(colon)
    {
        assert(row_num <= INT_MAX);
        msg_row = (int)row_num;
    }
}

static void do_intro_line(long row, uchar_kt *mesg, int attr)
{
    long col;
    uchar_kt *p;
    int l;
    int clen;

    // Center the message horizontally.
    col = vim_strsize(mesg);
    col = (Columns - col) / 2;

    if(col < 0)
    {
        col = 0;
    }

    // Split up in parts to highlight <> items differently.
    for(p = mesg; *p != NUL; p += l)
    {
        clen = 0;

        for(l = 0;
            p[l] != NUL && (l == 0 || (p[l] != '<' && p[l - 1] != '>'));
            ++l)
        {
            if(has_mbyte)
            {
                clen += ptr2cells(p + l);
                l += (*mb_ptr2len)(p + l) - 1;
            }
            else
            {
                clen += byte2cells(p[l]);
            }
        }

        assert(row <= INT_MAX && col <= INT_MAX);

        screen_puts_len(p, l, (int)row, (int)col,
                        *p == '<' ? hl_attr(HLF_8) : attr);
        col += clen;
    }
}

/// ":intro": clear screen, display intro screen and wait for return.
///
/// @param eap
void ex_intro(exargs_st *FUNC_ARGS_UNUSED_REALY(eap))
{
    screenclear();
    intro_message(TRUE);
    wait_return(TRUE);
}
